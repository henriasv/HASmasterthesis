\chapter{Simulation and analysis tools}
\label{ch:tools}
The molecular dynamics workflow can be usefully divided into the following steps: 
\begin{enumerate}
\item Create initial condition -- set initial positions and velocities for all particles and define bonding interactions.
\item Run molecular dynamics with a set of parameters.
\item Post-process.
\item Analyze results.
\end{enumerate}
Usually, step 3 will give experience that influence how steps 1 and 2 are done during the next iteration. It is important to have tools in place to accommodate this workflow. Most importantly, the tools have to be directly compatible when iterating $1 \to 2\to 3\to 4$. Otherwise, it is impossible to work efficiently. Second, it is convenient with compatibility $2\to 1$ if a simulation needs to be run further in time. Third, it is convenient with compatibility $4 \to 1$ and $4 \to 2$, but the nature of such a compatibility is not as clear as the others, and is probably a matter of insight of the user rather than a technical compatibility.

The most fundamental choice concerning tools is whether to program the molecular dynamics simulator myself or to use a program made by someone else. I have implemented my own simple molecular dynamics program before, and that experience tells me to use a package. It is quite easy to implement a simple molecular dynamics solver for Lennard-Jones particles in NVE and Berendsen NVT, but more complex potentials and barostatic ensembles are more challenging to implement and test. I used the Wikipedia overview of molecular dynamics simulators as a first guide for choosing a simulator, and then moved on to scanning scientific papers on topics adjacent to my project. From that, I considered that either LAMMPS or GROMACS would be the best choice of simulator. After a brief look on the documentations of the two packages, I chose LAMMPS, due to its user-friendliness. Another advantage of LAMMPS is that it is easy to extend with own code if the package itself doesn't contain sufficient functionality. That means LAMMPS covers step 2 of the workflow. 

Step 1 can also be partially covered by LAMMPS. First, LAMMPS have several built-in features to create initial conditions. Secondly, it is possible to code extensions to LAMMPS to create and modify initial conditions. I have also used a tool called Moltemplate to create LAMMPS-compatible data files describing a methane hydrate.

I found it useful to distinguish between step 3 and step 4 even though the difference is not too obvious. One way of explicitly separating them is by the tools used in each process. Post-processing is done by another tool than the tool that presents the data for analysis. 

The difference between steps 3 and 4 is not as clear as the difference between the other steps. I define it the following way. Post-processing is the processing of data prior to visualization. Analysis is the act of visualizing data that is already processed, and using that data to draw conclusions from the simulations. I will use Visual Molecular Dynamics (VMD) \cite{HUMP96} for visualization, and custom tools I develop myself in MATLAB, PYTHON and C++ for data analysis.

In the following sections of this chapter, I give an introduction to LAMMPS that contains the features that will be used later on, and then describe post-processing tools that I have developed. 

\section{LAMMPS}
LAMMPS \cite{Plimpton1995}, Large-scale Atomic/Molecular Massively Parallel Simulator, is a tool for (possibly) large particle-style simulations - mainly molecular dynamics. LAMMPS is a massive open source project, and its main features are developed and maintained at Sandia National Laboratories in the United States. 

\subsection{Input files}
LAMMPS input files are a set of commands to be executed. Some commands are only valid in the right order. The structure of such a file is:

\begin{enumerate}
\item \tb{Initialization:} Define the units (eg. SI or {\tt real}) of the simulation. Describe the simulation box. Define the interactions that will go into the simulation. 
\item \tb{Atom definition:} Set the initial positions (and optionally velocities) of the particles in the simulation. This can be done either from an input file or by generating positions according to some supported algorithm. The box boundaries are set in this section.
\item \tb{Settings:} Define the parameters of the particle interactions. Create output objects for thermodynamic data and particle trajectories etc. Optionally create particle velocities. Create the integrator (which can contain a thermostat).
\item \tb{Run:} Run the simulation.
\end{enumerate}

A small example of how a LAMMPS file for running a simulation with TIP4P/Ice water and united-atom methane is shown below. The initial positions are expected to come from a LAMMPS data file (explained later).
\begin{lstlisting}[language=LammpsInput]
# ----------------- Init Section -----------------
units 			real
dimension 		3
boundary		p p p 
atom_style		full
pair_style		lj/cut/tip4p/long 1 2 1 1 0.1577 10.0
kspace_style	pppm/tip4p 1.0e-4
bond_style 		harmonic
angle_style		harmonic
pair_modify		mix arithmetic

# ----------------- Atom Definition Section -----------------
read_data "water_methane_test.data"

# ----------------- Settings Section -----------------
pair_coeff	1 	1 	0.21084 	3.1668
pair_coeff	2 	2	0.0 		0.0
pair_coeff	1 	2 	0.0 		0.0
bond_coeff  1 	0.0 0.9572
angle_coeff 1 	0.0 104.52
pair_coeff  3 	3 	 0.29391 	3.73
pair_coeff 	1 3 	0.18 	3.44
pair_coeff 	2 3 	0.0 	0.0

group water type 1 2
group methane type 3
fix	fShakebond	water 	shake 	0.0001 100 0 a 1 b 1

dump myDump all custom 5 trajectory.lammpstrj id element x y z vx vy vz

velocity all create 300.0 32352 rot yes mom yes dist gaussian
fix fxnpt all npt temp 300.0 300.0 100.0 x 400.0 400.0 100.0

# ----------------- Run Section -----------------
run   5000
\end{lstlisting}
First, units are chosen. The meaning of {\tt real} units is best checked in the documentation \cite{lammps:documentation}. The choice of units has consequences for all physical properties that are to be set, such as temperature and interaction energies. On line 3, the simulation is set to be three-dimensional, and on line 4, all three boundaries are set to be periodic. {\tt atom\_style} limits what kinds of interactions are possible to use for a simulation using the particular input file. Full flexibility is obtained here by setting {\tt atom\_style full}. {\tt pair\_style} sets the potential for the non-bonding interactions, as described in \ref{sec:non_bonding_potentials}. Many types of {\tt pair\_style} potentials are available, and they can also be combined -- but with caution -- using the concept of hybrid pair styles. The {\tt kspace\_style} sets the long-range solver. Here it is set to P$^3$M, which is the only available long range solver in LAMMPS for the TIP4P water model. Then the bonding potential models are set to be harmonic (line 8-9). Lorentz-Berthelot combination rules are imposed with the command {\tt mix arithmetic}. The {\tt read\_data} command reads a LAMMS data file to import initial positions and bonding specification for all particles in the simulation. On lines 16-23, the coefficients for all the interactions are set. The first two arguments are the types of particles for which the coefficient shall be utilized, and the rest are the actual coefficients in an order dictated by the documentation of that specific potential. For the potentials here, the first coefficient is an energy, and the second either a distance or an angle. Then, two groups of particles are defined for convenience, and on line 27, the holonomic constraints on the water molecules are set to be handled by the SHAKE-algorithm. {\tt a 1 b 1} means that bonds of type 1 and angles of type 1 are to be constrained. The existence of these types of bonds and angles are set in the data file. Then, on line 29, the {\tt dump} command sets how the positions and velocities of particles is to be written to file. Here, all particles are set to be dumped to the file {\tt trajectory.lammpstrj} every fifth timestep. Then all particles are given an initial velocity from the Boltzmann distribution (Gaussian in each coordinate), and in line 32, the simulation is chosen to be run in the isothermic-isobaric ensemble (NPT). The standard thermostat for NPT in LAMMPS is Nos√©--Hoover both for the temperature and the pressure. The actual equations that are used, are the ones from \citet{shinoda2004rapid}.  The {\tt run} command on the final line sets the number of timesteps to be simulated.

\subsubsection{Data files}
It is usually a good idea to have all atom input information i a file separate from the input file, and read it with the data\_read command. An atom data file shall contain positions and velocities for all particles. In addition, if some atoms are parts of specific molecules, this is declared. All bonds and angles (and dihedrals and so on ..) that are meant to support interactions between specific particles must be declared. In addition, it is possible to insert coefficients for the different interactions. However, it is not possible to declare atom\_style, pair\_style or any other style in the data files. This has to be done in the input file, and it is important that the number of coefficients in the data file is compatible with the interaction potential chosen in the input file. 

Below are some extractions from an input file for bulk water with bonded O-H interactions, and angular H-O-H interactions. I have used this file to simulate TIP4P water, by keeping the bonds and angles rigid with the shake-algorithm. 

\begin{lstlisting}[language=LammpsData]
LAMMPS data file via write_data, version 11 Nov 2013, timestep = 15000

10125 atoms
2 atom types
6750 bonds
1 bond types
3375 angles
1 angle types

-1.2998053548485800e-01 4.6629980535484322e+01 xlo xhi
-1.2998053548485800e-01 4.6629980535484322e+01 ylo yhi
-1.2998053548485800e-01 4.6629980535484322e+01 zlo zhi

Masses

1 1.00794
2 15.9994

PairIJ Coeffs

1 1 0 0 10
1 2 0 0 10
2 2 0.16275 3.16435 10

Bond Coeffs

1 0 0.9572

Angle Coeffs

1 0 104.52

Atoms

721 241 2 -1.0484400000000000e+00 -6.2221407531032169e-02 1.5159166496011423e+00 5.3069458514672112e+00 0 0 0
1396 466 2 -1.0484400000000000e+00 4.0240333910499935e+00 4.2356159167994916e+00 1.7598269969646658e+00 0 0 0
1398 466 1 5.2422000000000002e-01 4.7736723529825049e+00 3.6734646891601108e+00 1.9555433512796152e+00 0 0 0
718 240 2 -1.0484400000000000e+00 1.6591102071344288e+00 1.3108233273533909e-01 3.7368290353832792e+00 1 0 0
2115 705 1 5.2422000000000002e-01 2.6288644528128606e+00 1.8244264320027685e+00 3.9483095929557672e+00 1 0 0
.
.
.

Velocities

721 -5.0354515315883175e-04 5.3167587742950842e-03 3.3571203451087726e-03
1396 2.9628128063741773e-04 -3.6999987020118080e-03 -6.2672614595795321e-03
1398 1.9834410211762494e-03 -4.5261896434727186e-04 -3.5219356644226700e-03
718 6.4570329589514993e-04 -1.2753082693010263e-03 5.5441917429848477e-03
2115 1.9812407347396029e-03 -1.4861789372548064e-03 2.0816584325493676e-02
143 -7.7275724561505395e-03 1.4979358537740204e-03 1.9557938914574084e-02
720 -8.5445971109074596e-03 -1.7755485312369985e-02 1.4432539996760280e-02
2114 8.2504630257354671e-03 -1.5862538887645005e-02 1.1754578049979690e-02
722 1.8121516439040641e-02 -5.4646869701048756e-03 2.3672874162716955e-03
767 -7.7201655772992407e-03 -5.5203125867209482e-03 -1.2033511911111539e-02

.
.
.

Bonds

1 1 721 722
2 1 721 723
3 1 1396 1397
4 1 1396 1398
5 1 718 719
6 1 718 720

.
.
.

Angles

1 1 722 721 723
2 1 1397 1396 1398
3 1 719 718 720
4 1 9452 9451 9453
5 1 767 766 768
6 1 2114 2113 2115
7 1 53 52 54
8 1 143 142 144

\end{lstlisting}

The first lines are ignored by LAMMPS, so the first line to be interpreted is line 3. The first section, line 3-8, contains information about what is supposed to be contained in this file. The next section defines the bounds on the simulation domain. Then comes a definition of the masses for the two atom types that were declared in the first section. In the section called PairIJ Coeffs, parameters for pair\_style interactions are set. The last line in this section tells that pair\_style interactions between particles of type 2 and 2 in this simulations have parameters 0.16275, 3.1643 and 10. The first two parameters in the 1 1 and 1 2 interactions have value 0, which tells us that these don't interact pair\_style. The bond coefficient section declares a bond with id 1. If there were to be additional types of bonded interactions, they would be numbered from 2 and so on. If the bond\_style is set to harmonic, the parameters for the first bond tells that the equilibrium distance in this harmonic bond is 0.9572, but that the coefficient for the harmonic force is 0. The reason for the coefficient to be zero in this specific case, is that the bond is to be rigid, and rigidity is handled later, by a fix-command. The angle coeffs section follows the same pattern as the bond coeffs. The contents of the Atoms section can vary, depending on the atom\_style used in the simulation. This setup is for atom\_style full. Line 35 tells that atom number 721 belongs to molecule number 241. It is of type 2 (oxygen in this case), and has charge -1.04844. Then comes xyz positions, and an nx ny nz counter telling how many times the atom has passed each periodic wall. Velocities are self-explanatory. The bonds section lists all the bonds that are defined in the simulation. In this case it is O-H-bonds in water. line 63 tells that the first such bond is of type 1 (as defined in bond coeffs), and that it creates a bonded interaction between atoms 721 and 722. The angles section is similar, but it takes three atoms to make an angle, with the vertex in the middle. 

This type of declaration is quite powerful. We have only defined that we have some water molecules, and that they support bonded and angular interactions, as well as pair\_style interactions. That means we can use any potential (supported by LAMMPS) that have these restrictions. The only thing that has to be changed, are the coefficients for the different interactions. If one wishes to change potentials regularly, it can be a good idea to put coefficients in a file together with the declaration of potentials, using the {\tt $<$pair, bond, angle$>$\_coeff } commands. 

\begin{comment}
\subsection{Computes in lammps}
\subsubsection{Pressure}
LAMMPS calculates the symmetric stress tensor for the system during each timestep, and stores it as a 6-element vector. The formula used for caculation is:
\begin{equation}
	P_{ij} = \frac{\sum_k^N  m_k v_{ki} v_{kj}}{V} + \frac{\sum_k^N r_{ki} f_{kj}}{V}
\end{equation}
Rigid sets of atoms with the SHAKE algorithm are accounted in this calculation. In practice, fix SHAKE adds forces to the atoms before integration to account for their holonomic constraints. These forces are included in the virial when calculating the pressure. 

\section{Optimizations in LAMMPS}
\subsection{OpenMP}
OpenMP support is implemented in the USER-OMP package. This has turned out not to be entirely stable. (Random crashes with cannot compute pppm)
\subsection{Processor layout and partitions}
{\tt run\_style verlet/split} distributes force calculations over two partitions of processors. These partitions must be defined either using the {\tt processor} command or the {\tt partition} command. {\tt verlet\_split} depends on the REPLICA package. 
\end{comment}

\section{Extending LAMMPS to cut elliptical prisms}
\label{subsec:reg_eprism}
LAMMPS was designed to be easily extendable, and in my opinion that turns out to be true. How to create extensions is explained in the section \emph{Modifying \& extending LAMMPS} in the LAMMPS documentation \cite{lammps:documentation}. I have made \emph{one} extension to LAMMPS, to be able to cut elliptical prisms. LAMMPS already contain features to remove atoms if they are defined to be in a group, so I only need to implement a way to define elliptical prismatic regions. The main contents of this extension is a function that determines whether a particle with a position $(x, y, z)$ is inside or outside the region:

\begin{lstlisting}[language=c++]
int RegEprism::inside(double x, double y, double z) 
{
	double dx = x-xmid;
	double dy = y-ymid;
	return ( (dx/a)*(dx/a)+(dy/b)*(dy/b) ) < 1.0;
}
\end{lstlisting}
The whole extension is implemented as a class that inherits from the LAMMPS {\tt class Region}. From the class definition of class region it can be seen that its subclasses are required to implement three functions:

\begin{lstlisting}[language=c++]
virtual int inside(double, double, double) = 0;
virtual int surface_interior(double *, double) = 0;
virtual int surface_exterior(double *, double) = 0;
\end{lstlisting}
I am not going to use the surface functions, so I only need to implement {\tt inside(...)}. I leave the other two as dummy functions returning {\tt false}, which means this region will be incompatible with other LAMMPS functionality if it requires knowledge of the surface properties of the region.

\begin{figure}
\centering
\includegraphics[width=8cm]{../snapshots/carved_crack.pdf}
\caption{An elliptic crack carved out using {\tt region eprism}}
\end{figure}


\subsection{Usage}
The usage of this extension is fairly straightforward. After compiling LAMMPS with the {\tt eprism} extension, an elliptical prismatic region can be defined by the following command:
\begin{lstlisting}[language=LammpsInput]
region <name> eprism <center x> <center y> <length x> <length y>
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Crack tracer}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Measuring the area of a crack surface is far from a trivial task. Due to the fractal-like interface between a molecular surface and the ``void'', at least one adjustable parameters must be included in a method for calculating the surface are of a crack in a molecular system. One possibility is to measure the solvent-accessible area, which has \emph{one} free parameter: The radius of a trial particle rolling over the molecular surface. 


\subsection{Algorithm}
I have implemented a Monte-Carlo crack tracer to measure the solvent-accessible area of a system of particles. The basic idea is that every point in space is defined as either part of the \emph{void} or part of the \emph{wall} based on the following definition: A void point is a point for which there exist no particles within a distance $r_p$. Points that are not part of the void are parts of the wall. The Monte-Carlo method I employ is as follows: $N$ line segments of length $\Delta l$ and uniformly random orientation and position in space are drawn. A surface point is detected if one of the edges is in the void while the other is in the wall. The line segments must be sufficiently short to only cross the void--wall interface once. The solvent-accessible surface area of the system can then be calculated with the following formula:

\begin{equation}
A_{ss}(r_p) = 2V\frac{n_s(r_p)}{N\Delta l}
\label{eq:crack_tracer}
\end{equation}
Which is a simplified version of the formula used in \citet{Bhattacharya2009}. $n_s$ is the number of surface points detected among $N$ line segments. $V$ is the volume of the system. The length $\Delta l$ is the only numerical resolution parameter for this measure, and has to be small compared to $r_p$ in order to capture the surface structure. Note that one could in principle draw line segments of different lengths. The denominator just have to be the sum of the length of all line segments. Actually, the formula can be written
\begin{equation}
	A_{ss}(r_p) = 2V\frac{n_s(r_p)}{L}
\end{equation}
$n_s$ is now the total number of void--wall crossings of an arbitrary set of straight line segments of total length $L$. Each line is now allowed to cross the void--wall interface arbitrarily many times, provided that the total number is added to $n_s$.

\begin{figure}
\centering
\begin{tikzpicture}
\filldraw[blue!40!white] (0, 0) rectangle (6, 12);
\draw[very thick] (0,0) -- (6, 0);
\draw[very thick] (0,12) -- (6, 12);
\fill[name path=myellipse, white] (3, 6) ellipse (0.4cm and 1.4cm);
\pgfmathsetseed{1138}
\foreach \x in {1,2,...,400} 
{
	\pgfmathrandominteger{\a}{0}{600}
	\pgfmathrandominteger{\b}{0}{1200}
	\pgfmathrandominteger{\c}{0}{359}
	\pgfmathrandominteger{\d}{0}{180}
	\pgfmathsetmacro{\length}{0.4*cos(\d)}
	%\def\length{\pgfmathresult}
	\draw[name path=myline] (\a/100,\b/100) -- ++(\c:\length);
	\def\n{0}
	\fill [execute at begin node={\global\let\n=\n}, name intersections={of = myline and myellipse, total=\n}];
	\pgfmathifthenelse{\n==1}{"\noexpand\fill [red] (intersection-1) circle (2pt)"}{"\noexpand\fill [blue] (2, 2) circle (0pt)"}
	\pgfmathresult ;
}
\end{tikzpicture}
\caption{Illustration of the crack tracer method. Here, 400 line segments of length \SI{0.4}{\centi\meter} are drawn. The line segments appear to have different lengths since they also have a component perpendicular to the paper plane. Red dots indicate the intersection of a line segment with the crack surface.  If thinking in two dimensions, the area of this system, $\SI{6}{\centi\meter} \times \SI{12}{\centi\meter}$, takes the role of the volume, and the surface area becomes a length. The calculated surface length is then: $2\times \SI{72}{\centi\meter\squared} \frac{6}{400\times \SI{0.3}{\centi\meter}} = \SI{5.4}{\centi\meter}$. The true circumference of the crack in this example is around \SI{6.5}{\centi\meter}.}
\label{fig:crack_tracer_method}
\end{figure}

Figure \ref{fig:crack_tracer_method} shows the method in action, with the blue area as the wall and the white area as the void. 

\subsection{Implementation}
\paragraph{Cell lists}
The system is divided into a maximum number of equal sized cells such that that all cell dimensions $l_x, l_y, l_z$ are greater than $r_p$. When a point is checked for whether it is part of the void or the wall, only the distance to particles belonging to the same cell and the directly and diagonally adjacent cells need to be checked. Using cell lists rather that looping over all particles in the system gives huge efficiency gains.
\paragraph{Periodic boundaries}
Periodic boundaries are implemented using cell lists, which means that the system must be at least $2\times 2 \times 2$ cells ‚Äì each dimension in the system must be at least $2r_p$.
\paragraph{Scaling efficiency}
If we assume that the required number of samples to estimate the surface area of a system is proportional to the number of particles in that system, the problem scales as $\mathcal{O}(N^2)$. With cell lists the problem scales like $\mathcal{O}(N)$.

\subsection{Choice of parameters}
As mentioned, there are two parameters to be chosen when applying this technique. First, $r_p$ has to be chosen to define what surface is to be measured. Different $r_p$ correspond to different solvent accessible surfaces. The resolution at which this surface is to be measured shall be chosen. A low value of $\Delta l$ will capture details of the surface, and $\Delta l$ should be significantly smaller than the characteristic size of the surface roughness. The cost of a small $\Delta l$ is bad statistics. The shorter the line segments, the smaller the portion of segments that cross the void-wall boundary. Figure \ref{fig:crack_trace_test} shows the calculated crack surface area as a function of $\Delta l$ and $r_p$ for a crack in a sI hydrate during crack propagation. 

\begin{figure}
\centering
\includegraphics[width=10cm]{../figures/thesis/crack_tracer_test.pdf}
\caption{Calculated crack surface area as a function of $\Delta l$ and $r_p$ for a crack propagating in a system of $24\times 24 \times 12$ sI unit cells. The high values corresponding to low values of $r_p$ are because the trial particle will fit inside the methane hydrate cells -- parts of a standard unit cell will be considered void. For high $r_p$, the crack is not wide enough for a trial particle to fit in. The length of the line segments is unimportant compared to the size of the trial particle, but consistent with intuition: The measured crack surface area slightly increases when $\Delta l$ decreases.}
\label{fig:crack_trace_test}
\end{figure}


\section{Stress measurement}
I output the stress tensor for each particle, usually averaged over some hundreds of integration steps. These values are put on a 2D grid, and averaged for each cell on that grid. This kind of measurement is not necessarily useful for methane hydrates, as the characteristic size is large (\SI{12}{\angstrom}) so that the grid must necessarily be coarse, but the measurement can be interesting to illustrate the stress field, and check that it is qualitatively similar to the stress fields in continuum fracture mechanics. It turns out that the best results are obtained by using the same number of grid points as there are unit cells in each direction, which is not surprising, since This erases the inhomogeneities occurring within each unit cell. Slightly lower or higher resolutions of the grid result in serious artifacts and much higher resolutions results in very few atoms contributing to each grid cell, which gives bad statistics and useless results. The stressfield from a representative simulation of a strained methane hydrate with a crack in it, measured with different resolutions of the averaging grid, is shown in figure \ref{fig:artefacts}.

\begin{figure}
\includegraphics[width=\textwidth]{../figures/thesis/stressfield_artefacts.pdf}
\caption{Measured stress fields in the $xy$-plane with different resolutions of the cell grid. The modeled system is $24\times 24\times 12$ sI unit cells. We see that $N=24$ and $N=12$ works well. $N=48$ gives a checkered pattern, but it is possible to see the stress field. The highest resolution available without artifacts is the number of unit cells in each direction.}
\label{fig:artefacts}
\end{figure}

\section{Other tools}
In addition to the tools already mentioned, I have implemented several shorter pieces of code to create plots and to calculate various properties like the diffusion constant and the viscosity in the model. I choose not to describe these in detail.